#!/usr/bin/env groovy

def methods
def machinesList
/*
 Initialization: checkout the production repository to load the files:
 - "util.groovy" with the functions used in the pipeline scripts
 - "Machines.groovy" with the list and properties of HPC systems
*/
stage('Initialization') {
    node('master') {
        checkout scm
        methods = load("$WORKSPACE/jenkins/util.groovy")
        machinesList = load("$WORKSPACE/jenkins/Machines.groovy")
    }
}

/*
 Machine Selection:
 - filters the user defined parameter "machines", accessible though "params.machines"
 - defines the runtime HPC systems of the project "machinesToRun"
 - defines the configuration of the runtime HPC systems "machinesConfiguration"
*/
def machineConfigurations = []
stage('Machine Selection') {
    node('master') {
        def machinesToRun = machinesList.findAll({methods.machineCheck(params.machines, it.name)})
        if (!machinesToRun) {
            println "No machines were specified. Aborting...."
            currentBuild.result = "FAILURE"
            return
        }
        for (system in machinesToRun) {
            machineConfigurations.add(
                [machine:system, architectures: methods.getMachineConfiguration(
                        params.machines, system.name, system.archs as String[])])
        }
    }
}

/*
 Build Stage: configures parallel builds for the different "machinesToRun"
 Loop over all systems in "machineConfigurations":
  - if the machine has multiple architectures, starts a sub-loop over architectures
  - the user parameter "eb_prefix" is prepended to the variable EASYBUILD_PREFIX
  - EBVERSIONEASYBUILD stores the version of EasyBuild ("params.eb_version")
  - the target CDT version is selected by the user and stored in "params.cdt_version"
*/
def builds = [:]
def toolchains = ['CrayCCE', 'CrayGNU', 'CrayIntel', 'CrayPGI']
stage('Build Stage') {
    for (system in machineConfigurations) {
        def machine = system.machine
        def architectures = system.architectures
        def machineName = machine.name
        for (item in architectures) {
            /* define architecture and machineLabel
               to use them in parallel builds */
            def architecture = item
            def machineLabel = architecture == "" ?
               machineName :
               "$machineName-$architecture"
            builds["$machineLabel"] = {
                node(machineName) {
                    checkout scm

                    /* define command to load EasyBuild */
                    def load_easybuild = architecture == "" ?
                        "module load cdt/${params.cdt_version} EasyBuild-custom/cscs" :
                        "module load cdt/${params.cdt_version} daint-$architecture EasyBuild-custom/cscs"

                    /* define command to switch EasyBuild version*/
                    def switch_easybuild = params.eb_version == "" ?
                        "" :
                        "module switch EasyBuild EasyBuild/${params.eb_version}"

                    /* define list of unuse paths */
                    def unuse_paths = architecture == '' ?
                        machine.unusePath.replace(':', ' ') :
                        machine.unusePath.replace(':', ' ').replace('ARCH', architecture)
                        println("List of unuse paths: $unuse_paths")

                    /* define toolchain names and corresponding EasyBuild recipes */
                    def current_tc = toolchains.collect{"$it-${params.cdt_current}.eb"}.join(' ')
                    println "Current toolchains: $current_tc"

                    /* define toolchain flags and command to build toolchains */
                    def tc_flags = "--hidden --ignore-locks --try-software-version=${params.cdt_version}"
                    def build_toolchains = architecture == "" ?
                        "srun -u -J $env.JOB_BASE_NAME --account=${params.account} -t 00:05:00 eb $current_tc $tc_flags" :
                        "srun -u -C $architecture -J $env.JOB_BASE_NAME --account=${params.account} -t 00:05:00 eb $current_tc $tc_flags"

                    /* build toolchains */
                    sh("""#!/bin/bash -l
                        export EASYBUILD_PREFIX="${params.eb_prefix}/$machineLabel/${params.cdt_version}"
                        export EASYBUILD_TMPDIR="\$EASYBUILD_PREFIX/tmp"
                        export EASYBUILD_BUILDPATH="/tmp/$env.BUILD_TAG"
                        export EB_CUSTOM_REPOSITORY="$WORKSPACE/easybuild"
                        $load_easybuild
                        $switch_easybuild
                        for path in $unuse_paths; do
                         module unuse \$path
                        done
                        echo -e "\nMODULEPATH: \$MODULEPATH\n"
                        export EASYBUILD_EXTERNAL_MODULES_METADATA=$WORKSPACE/easybuild/cray_external_modules_metadata-${params.cdt_version}.cfg

                        # print EasyBuild version and configuration
                        eb --version
                        eb --show-config

                        # build toolchains
                        status=0
                        $build_toolchains
                        status=\$[status+\$?]

                        exit \$status""")

                    /* define software flags and command to build software */
                    def sw_flags = "--ignore-locks --try-toolchain-version=${params.cdt_version} -r"
                    def build_command = architecture == "" ?
                        "srun -u -J $env.JOB_BASE_NAME --account=${params.account} -t 06:00:00 eb $sw_flags" :
                        "srun -u -C $architecture -J $env.JOB_BASE_NAME --account=${params.account} -t 06:00:00 eb $sw_flags"

                    /* build the software stack with the new toolchains */
                    sh("""#!/bin/bash -l
                        export EASYBUILD_PREFIX="${params.eb_prefix}/$machineLabel/${params.cdt_version}"
                        export EASYBUILD_TMPDIR="\$EASYBUILD_PREFIX/tmp"
                        export EASYBUILD_BUILDPATH="/tmp/$env.BUILD_TAG"
                        export EB_CUSTOM_REPOSITORY="$WORKSPACE/easybuild"
                        $load_easybuild
                        $switch_easybuild
                        for path in $unuse_paths; do
                            module unuse \$path
                        done
                        echo -e "\nMODULEPATH: \$MODULEPATH\n"
                        export EASYBUILD_EXTERNAL_MODULES_METADATA="$WORKSPACE/easybuild/cray_external_modules_metadata-${params.cdt_version}.cfg"

                        # print EasyBuild version and configuration
                        eb --version
                        eb --show-config

                        # initialise counters and lists
                        unset success
                        success_file="\${EASYBUILD_PREFIX}/success.txt"
                        echo "" > \${success_file}
                        unset failed
                        failed_file="\${EASYBUILD_PREFIX}/failed.txt"
                        echo "" > \${failed_file}

                        # filter the target production list $machineLabel
                        echo ${params.select_recipes} | tr " ," "\n" > select_recipes.txt
                        echo ${params.discard_recipes} | tr " ," "\n" > discard_recipes.txt
                        build_list=\$(grep -if select_recipes.txt $WORKSPACE/jenkins-builds/$machineLabel | grep -ivf discard_recipes.txt | awk '{print \$1}')
                        
                        if [ -z "\$build_list" ]; then
                            echo -e "\nThe list of recipes to build is empty. Exiting..."
                            exit \$(wc -w <<< \$build_list)
                        else   
                            echo -e "\nSelected recipes to build: \n\$build_list" | sed -E 's/(Cray.+)-${params.cdt_current}/\\1-${params.cdt_version}/'
                        fi

                        # build recipes
                        for recipe in \${build_list}; do
                            status=0
                            new_recipe=\$(echo \$recipe | sed -E 's/(Cray.+)-${params.cdt_current}/\\1-${params.cdt_version}/')
                            echo -e "\nBuilding \$new_recipe"
                            eb \$recipe --try-toolchain-version=${params.cdt_version} -Dr 2>&1 | grep -iv "== temporary"

                            echo -e "\nSubmitting job and building..."
                            $build_command \$recipe
                            status=\$[status+\$?]

                            # keep track of successful and failed builds
                            folder=\$(find . -name \$recipe | xargs dirname)
                            if [ \$status -eq 0 ]; then
                                success+=(\$new_recipe)
                                echo "\$folder/\$new_recipe" >> "\${success_file}"
                                # remove folders
                                echo -e "\nBuild of \$new_recipe from \$recipe SUCCESSFUL(\${#success[@]})"
                            else
                                failed+=(\$new_recipe)
                                echo "\$folder/\$new_recipe" >> "\${failed_file}"
                                # archive folders
                                echo -e "\nBuild of \$new_recipe from \$recipe FAILED(\${#failed[@]})"
                            fi
                        done

                        # change permission of tmp folders if failed is not null
                        if [ -n "\$failed" ]; then
                            chmod -R o+r "\${EASYBUILD_TMPDIR}"
                            find "\${EASYBUILD_TMPDIR}" -type d -exec chmod o+x '{}' \\;
                        fi

                        # print successful and failed builds
                        echo -e "\nSuccessful Builds: \${#success[@]} \n\${success[@]}"
                        echo -e "\nFailed Builds: \${#failed[@]} \n\${failed[@]}"
                    """)
                }
            }
        }
    }

    try {
        parallel builds

        // merge workspaces and create PR's
        node('dom') {
            /* setup github repo */
            sh("""#!/bin/bash -l
                ### clone master over ssh
                git clone git@github.com:eth-cscs/production.git
                cd  production

                ### create git branch or update if exists
                git checkout exp/${params.cdt_version} || git checkout -b exp/${params.cdt_version}
                git status
                git --no-pager diff origin/master --stat
            """)

            /* copy newly created toolchains to new workspace */
            for (toolchain in toolchains) {
                def source = "${params.eb_prefix}/*/${params.cdt_version}/software/${toolchain}/${params.cdt_version}/easybuild/${toolchain}-${params.cdt_version}.eb"
                def target = "$WORKSPACE/production/easybuild/easyconfigs/c/$toolchain"
                sh "cp -f ${source} ${target} || true"
            }

            /* create PR with new recipes */
            sh("""#!/bin/bash -l
                module load daint-gpu
                module load hub
                cd $WORKSPACE/production

                failed_files="${params.eb_prefix}/*/${params.cdt_version}/failed.txt"
                success_files="${params.eb_prefix}/*/${params.cdt_version}/success.txt"

                wc \$failed_files
                failed=\$(cat \$failed_files | sort | uniq)

                wc \$success_files
                success=\$(cat \$success_files | sort | uniq)

                for new_recipe in \${success[@]}; do
                    echo \$new_recipe
                    # check if recipe didn't fail somewhere else
                    if fgrep -H \$new_recipe ${params.eb_prefix}/*/${params.cdt_version}/failed.txt; then
                        echo -e "\$new_recipe found in failed builds"
                    else
                        # copy new recipe onto the correct folder
                        folder=\$(dirname \$new_recipe)
                        recipe=\$(basename \$new_recipe)
                        echo \$folder \$recipe
                        source="${params.eb_prefix}/*/${params.cdt_version}/software/*/*/easybuild/reprod/\$recipe"
                        # expand pattern and copy first item found
                        source=(\$source)
                        ls -lh \$source
                        cp \$source \$folder
                    fi
                done

                git add easybuild/easyconfigs
                git status
                git commit -m "Add recipes for cdt/${params.cdt_version}"
                git push origin HEAD

                if [ $createPR ]; then
                    hub pull-request -m "WIP [dom] Add recipes for cdt/${params.cdt_version}"
                fi

                # print all failed builds
                echo -e "\nFailed Builds: \${#failed[@]} \n\${failed[@]}"
                # TO DO: open Jira issue or GitHub WIP PR with failed recipes

                # return the number of failed Builds
                exit \${#failed[@]}
            """)
        }
        currentBuild.result = "SUCCESS"
    } catch(err) {
        if (err.toString().contains('exit code 143')) {
            currentBuild.result = "ABORTED"
            println "The Build step was cancelled. Aborting..."
        }
        else if (err.toString().contains('Queue task was cancelled')) {
            currentBuild.result = "ABORTED"
            println "The Queue task was cancelled. Aborting..."
        }
        else {
            currentBuild.result = "FAILURE"
            println "The Build step failed. Exiting..."
        }
    }
}
